"Games"
{
	"insurgency"
	{
		"Addresses"
		{
			"TheNavMesh"
			{
				"linux"
				{
					"signature"	"TheNavMesh"
				}
				"windows"
				{
					"signature"	"TheNavMesh"
					"read"		"17"
				}
			}
			"g_pGameRules"
			{
				"linux"
				{
					"signature"	"g_pGameRules"
				}
				// TODO: Windows — same as TheNavMesh; needs pattern scan approach.
			}
		}

		"Signatures"
		{
			// ----- Global addresses -----

			// CNavMesh *TheNavMesh — global pointer (BSS segment)
			// Linux offset from server base: 0x00c99800
			// Windows: RVA 0x70b954 — extracted via read offset from a function
			//   that does mov ecx, [TheNavMesh] (function at RVA 0x33fe90)
			"TheNavMesh"
			{
				"library"	"server"
				"linux"		"@TheNavMesh"
				"windows"	"\x55\x8B\xEC\x83\xEC\x0C\x56\x8B\xF1\x8D\x45\xF4\x6A\x00\x51\x8B\x0D\x2A\x2A\x2A\x2A\xF3\x0F\x10\x46\x04\xF3\x0F\x11\x45\xF4\xF3"
			}

			// CGameRules *g_pGameRules — global pointer
			// Expected offset: 0x00c0c3d8
			// Windows: no exported symbol; TODO needs pattern scan
			"g_pGameRules"
			{
				"library"	"server"
				"linux"		"@g_pGameRules"
			}

			// ----- DHook detour targets -----

			// void CINSBotCombat::Update(ActionResult *sret, void *this, CINSNextBot *actor, float interval)
			// x86-32 sret ABI: ActionResult returned via hidden first stack param
			// Linux offset: 0x00706550  Windows: 1028d440 [EXACT vtable[50], 89 bytes]
			// Windows callconv: thiscall with sret — DHooks Functions entry needs updating for Windows
			"CINSBotCombat::Update"
			{
				"library"	"server"
				"linux"		"@_ZN13CINSBotCombat6UpdateEP11CINSNextBotf"
				"windows"	"\x55\x8B\xEC\x56\x8B\x75\x08\x85\xF6\x74\x49\x8B\x06\x8B\xCE\x8B\x80\x14\x01\x00\x00\xFF\xD0\x84\xC0\x74\x39\x8B\xCE\xE8\x6E\xFF"
			}

			// void CINSBotActionCheckpoint::Update(ActionResult *sret, void *this, CINSNextBot *actor, float interval)
			// Linux offset: 0x00726a50  Windows: 102889b0 [CORRECTED vtable[49] (-1), 1267 bytes]
			"CINSBotActionCheckpoint::Update"
			{
				"library"	"server"
				"linux"		"@_ZN23CINSBotActionCheckpoint6UpdateEP11CINSNextBotf"
				"windows"	"\x55\x8B\xEC\x83\xEC\x14\x53\x56\x57\x8B\x7D\x0C\x8B\xD9\x8B\x87\x4C\x20\x00\x00\x8D\xB7\x4C\x20\x00\x00\x8B\xCE\xFF\x90\xD8\x00"
			}

			// ----- SDKCall targets -----

			// void CINSBotLocomotion::Approach(const Vector &goal, float weight)
			// Windows: 1035fa40 [EXACT vtable[50], 40 bytes]
			"CINSBotLocomotion::Approach"
			{
				"library"	"server"
				"linux"		"@_ZN17CINSBotLocomotion8ApproachERK6Vectorf"
				"windows"	"\x55\x8B\xEC\x57\xFF\x75\x08\x8B\xF9\xE8\x2A\x2A\x2A\x2A\x8B\x07\x51\xC7\x04\x24\x00\x00\x80\x3F\x8B\xCF\xFF\x75\x08\xFF\x90\xC4"
			}

			// CNavMesh::GetNearestNavArea(const Vector&, bool, float, bool, bool, NearestNavAreaGroundCheck_t) const
			// Linux offset: 0x004f20d0
			// Windows: RVA 0x33ec90 — found via GetNavArea VPROF string xref chain
			"CNavMesh::GetNearestNavArea"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavMesh17GetNearestNavAreaERK6Vectorbfbb27NearestNavAreaGroundCheck_t"
				"windows"	"\x55\x8B\xEC\x81\xEC\xDC\x00\x00\x00\x83\x79\x18\x00\x89\x4D\xFC\x75\x08\x33\xC0\x8B\xE5\x5D\xC2\x18\x00\xF3\x0F\x10\x5D\x10\x56"
			}

			// CNavArea::IsPotentiallyVisible(const CNavArea*) const
			// Linux offset: 0x004ae260  Windows: 10319aa0 [EXACT vtable[33], 204 bytes]
			// 56-byte sig needed: first 32 bytes had only 20 fixed (3 VPROF globals relocated)
			"CNavArea::IsPotentiallyVisible"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavArea20IsPotentiallyVisibleEPKS_"
				"windows"	"\x55\x8B\xEC\x51\x53\x8B\xD9\x8B\x0D\x2A\x2A\x2A\x2A\xFF\x15\x2A\x2A\x2A\x2A\x88\x45\xFF\x84\xC0\x74\x1C\x8B\x0D\x2A\x2A\x2A\x2A\x6A\x04\x6A\x00\x68\x2A\x2A\x2A\x2A\x6A\x00\x68\x2A\x2A\x2A\x2A\xFF\x15\x2A\x2A\x2A\x2A\x56\x57"
			}

			// CNavArea::IsBlocked(int, bool) const
			// Linux offset: 0x004adc40  Windows: 103186f0 [CORRECTED vtable[17] (-1), 62 bytes]
			// vtable[17] checks team flags — matches IsBlocked(int,bool) signature
			"CNavArea::IsBlocked"
			{
				"library"	"server"
				"linux"		"@_ZNK8CNavArea9IsBlockedEib"
				"windows"	"\x55\x8B\xEC\x80\x7D\x0C\x00\x74\x0F\xF7\x41\x68\x00\x00\x00\x80\x74\x06\x32\xC0\x5D\xC2\x08\x00\x8B\x45\x08\x83\xF8\xFF\x75\x0A"
			}

			// CINSRules::IsCounterAttack() const
			// Linux offset: 0x0022e150  Windows: 1022e1a0 [CORRECTED vtable[269] (-2), 7 bytes]
			// mov al, [ecx+0x3AC]; ret — reads m_bCounterAttack field
			"CINSRules::IsCounterAttack"
			{
				"library"	"server"
				"linux"		"@_ZNK9CINSRules15IsCounterAttackEv"
				"windows"	"\x8A\x81\xAC\x03\x00\x00\xC3"
			}

			// CINSPlayer::GiveAmmo(int ammoType, int count, int roundsPerMag, bool silent, int maxMags)
			// Handles both magazine-based (flag 0x4 → AddMags) and non-magazine weapons.
			// Returns number of magazines added.
			// Windows: TODO — not extracted by Ghidra script
			"CINSPlayer::GiveAmmo"
			{
				"library"	"server"
				"linux"		"@_ZN10CINSPlayer8GiveAmmoEiiibi"
			}
		}

		"Offsets"
		{
			// ----- CNavArea field offsets (32-bit, verified from binary) -----

			"CNavArea::m_center"
			{
				"linux"		"44"
				"windows"	"44"
			}
			"CNavArea::m_connect"
			{
				"linux"		"108"
				"windows"	"108"
			}
			"CINSNavArea::m_insFlags"
			{
				"linux"		"352"
				"windows"	"352"
			}
			"CINSNavArea::m_deathIntensity"
			{
				"linux"		"536"
				"windows"	"536"
			}
			"CINSNavArea::m_deathTimestamp"
			{
				"linux"		"552"
				"windows"	"552"
			}
			"CINSNavArea::m_hidingSpots"
			{
				"linux"		"208"
				"windows"	"208"
			}

			// CBaseCombatWeapon::GetMaxClip1() — max rounds per magazine
			"GetMaxClip1"
			{
				"linux"		"325"
				"windows"	"324"
			}

			// ----- VTable indices (byte_offset / 4 on 32-bit) -----

			// CINSNextBot::GetLocomotionInterface() const — vtable byte 0x96c
			"GetLocomotionInterface"
			{
				"linux"		"603"
				"windows"	"603"
			}
			// CINSNextBot::GetBodyInterface() const — vtable byte 0x970
			"GetBodyInterface"
			{
				"linux"		"604"
				"windows"	"604"
			}
			// CINSNextBot::GetVisionInterface() const — vtable byte 0x974
			"GetVisionInterface"
			{
				"linux"		"605"
				"windows"	"605"
			}
			// IBody::AimHeadTowards(const Vector&, int, float, INextBotReply*, const char*) — vtable byte 0xd4
			"IBody::AimHeadTowards"
			{
				"linux"		"53"
				"windows"	"53"
			}
			// IVision::IsAbleToSee(CBaseEntity*, int checkFOV, Vector* visibleSpot) — vtable byte 260
			"IVision::IsAbleToSee_Entity"
			{
				"linux"		"65"
				"windows"	"65"
			}
			// IVision::GetPrimaryKnownThreat(int onlyVisible) — vtable byte 0xd0
			"IVision::GetPrimaryKnownThreat"
			{
				"linux"		"52"
				"windows"	"52"
			}
			// CBaseEntity::SpeakConceptIfAllowed(...) — vtable byte 0x800
			"SpeakConceptIfAllowed"
			{
				"linux"		"512"
				"windows"	"512"
			}
		}

		"Functions"
		{
			// ----- DHook detour definitions -----
			// Using cdecl because on Linux x86-32 GCC, thiscall puts this on stack.
			// With sret ABI, the hidden sret pointer precedes this on the stack.
			// We declare ALL stack params explicitly: sret, this, actor, interval.

			"CINSBotCombat_Update"
			{
				"signature"	"CINSBotCombat::Update"
				"callconv"	"cdecl"
				"return"	"void"
				"arguments"
				{
					"sret"
					{
						"type"	"int"
					}
					"thisptr"
					{
						"type"	"int"
					}
					"actor"
					{
						"type"	"int"
					}
					"interval"
					{
						"type"	"float"
					}
				}
			}

			"CINSBotActionCheckpoint_Update"
			{
				"signature"	"CINSBotActionCheckpoint::Update"
				"callconv"	"cdecl"
				"return"	"void"
				"arguments"
				{
					"sret"
					{
						"type"	"int"
					}
					"thisptr"
					{
						"type"	"int"
					}
					"actor"
					{
						"type"	"int"
					}
					"interval"
					{
						"type"	"float"
					}
				}
			}

			// ----- SDKCall function definitions -----

			"CINSBotLocomotion::Approach"
			{
				"signature"	"CINSBotLocomotion::Approach"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"address"
				"arguments"
				{
					"goal"
					{
						"type"	"vectorptr"
					}
					"weight"
					{
						"type"	"float"
					}
				}
			}
		}
	}
}
